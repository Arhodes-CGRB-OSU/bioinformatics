#!/usr/bin/python
import os, sys, re
import getopt
from low import  *
from Bio.Seq import Seq,reverse_complement
from Bio import Translate
from Bio.Alphabet import IUPAC

UnambiguousTranslator = Translate.unambiguous_dna_by_id[1]

# =============================================================================  
def show_help( ):
  """ displays the program parameter list and usage information """
  stdout( "usage: " + sys.argv[0] + " -f <path> -o outfile" )
  stdout( " " )
  stdout( " option    description" )
  stdout( " -h        help (this text here)" )
  stdout( " -f        path to the paml.filelist file generated by another python script" )
  stdout( " -a        path to the TAIR functional description file" )
  stdout( " -o        summary outfile" )
  stdout( " " )
  sys.exit(1)


# =============================================================================
def handle_arguments():
  """ checks given arguments and returns either an error mesasge
  or a hash of the correctly defined arguments """
  
  if len ( sys.argv ) == 1:
    stderr( "no arguments provided." )
    show_help()  
  
  try: # check for the right arguments
    keys, values = getopt.getopt( sys.argv[1:], "hf:o:a:" )
  except getopt.GetoptError:
    stderr( "invalid arguments provided." )
    show_help()
    
  args = {}
  
  for key, value in keys: # handle arguments
    if key == '-f': args[ 'filelist' ] = value
    if key == '-o': args[ 'outfile' ] = value
    if key == '-a': args[ 'annofile' ] = value
    
  if not args.has_key( 'filelist' ):
    stderr( "filelist is missing." )
    show_help()
  elif not file_exists( args[ 'filelist' ] ):
    stderr( "filelist does not exist: " + value )
    show_help()
  else:
    args['filelist'] = get_global_path( args.get('filelist') )
    
  if not args.has_key( 'annofile' ):
    stderr( "annotation file is missing." )
    show_help()
  elif not file_exists( args[ 'annofile' ] ):
    stderr( "annotation file does not exist: " + value )
    show_help()
  else:
    args['annofile'] = get_global_path( args.get('annofile') )
    
  if not args.has_key( 'outfile' ):
    stderr( "outfile is missing." )
    show_help()
  else:
    args['outfile'] = get_global_path( args.get('outfile') )
  
  args['outdir'] = os.path.split(args['filelist'])[0]
  if not args['outdir'].endswith('/'): args['outdir'] += '/'
  
  return args


# =============================================================================
def Ka_Ks_with_PAML( filelist, annofile, outdir, outfile ):
  """
  uses the PAML package to analyze each MSA for synonymous and nonsynonymous
  substitutions. Therefore, control files are generated, and the program
  is executed for each file.
  """
  def generate_codeml_ctl_file( filename, seqfile, treefile, outfile ):
    
    fw = open( filename, 'w' )
    fw.write( "seqfile = " + seqfile + " * sequence data file name\n" )
    fw.write( "treefile = " + treefile + " * tree structure file name\n" )
    fw.write( "outfile = " + outfile + " * main result file\n" )
    
    fw.write( "noisy = 0 * 0,1,2,3,9: how much rubbish on the screen\n" )
    fw.write( "verbose = 0 * 1: detailed output, 0: concise output\n" )
    fw.write( "runmode = 0 * 0: user tree; 1: semi-automatic; 2: automatic * 3: StepwiseAddition; (4,5):PerturbationNNI; -2: pairwise\n" )
    fw.write( "seqtype = 1 * 1:codons; 2:AAs; 3:codons-->AAs\n" )
    fw.write( "CodonFreq = 2 * 0:1/61 each, 1:F1X4, 2:F3X4, 3:codon table\n" )
    #fw.write( "* ndata = " + str(ndata) + "\n" )
    fw.write( "clock = 0 * 0:no clock, 1:clock; 2:local clock; 3:TipDate\n" )
    fw.write( "aaDist = 0 * 0:equal, +:geometric; -:linear, 1-6:G1974,Miyata,c,p,v,a * 7:AAClasses\n" )
    fw.write( "aaRatefile = jones.dat * only used for aa seqs with model=empirical(_F) * dayhoff.dat, jones.dat, wag.dat, mtmam.dat, or your own\n" )
    fw.write( "model = 0 * models for codons:\n" )
    fw.write( "* 0:one, 1:b, 2:2 or more dN/dS ratios for branches\n" )
    fw.write( "* models for AAs or codon-translated AAs:\n" )
    fw.write( "* 0:poisson, 1:proportional,2:Empirical,3:Empirical+F\n" )
    fw.write( "* 6:FromCodon, 8:REVaa_0, 9:REVaa(nr=189)\n" )
    fw.write( "NSsites = 0 * 0:one w;1:neutral;2:selection; 3:discrete;4:freqs;\n" )
    fw.write( "* 5:gamma;6:2gamma;7:beta;8:beta&w;9:beta&gamma;\n" )
    fw.write( "* 10:beta&gamma+1; 11:beta&normal>1; 12:0&2normal>1;\n" )
    fw.write( "* 13:3normal>0\n" )
    fw.write( "icode = 0 * 0:universal code; 1:mammalian mt; 2-11:see below\n" )
    fw.write( "Mgene = 0 * 0:rates, 1:separate;\n" )
    fw.write( "fix_kappa = 0 * 1: kappa fixed, 0: kappa to be estimated\n" )
    fw.write( "kappa = 2 * initial or fixed kappa\n" )
    fw.write( "fix_omega = 0 * 1: omega or omega_1 fixed, 0: estimate\n" )
    fw.write( "omega = .4 * initial or fixed omega, for codons or codon-based AAs\n" )
    fw.write( "fix_alpha = 1 * 0: estimate gamma shape parameter; 1: fix it at alpha\n" )
    fw.write( "alpha = 0. * initial or fixed alpha, 0:infinity (constant rate)\n" )
    fw.write( "Malpha = 0 * different alphas for genes\n" )
    fw.write( "ncatG = 3 * # of categories in dG of NSsites models\n" )
    fw.write( "fix_rho = 1 * 0: estimate rho; 1: fix it at rho\n" )
    fw.write( "rho = 0. * initial or fixed rho, 0:no correlation\n" )
    fw.write( "getSE = 0 * 0: don't want them, 1: want S.E.s of estimates\n" )
    fw.write( "RateAncestor = 0 * (0,1,2): rates (alpha>0) or ancestral states (1 or 2)\n" )
    fw.write( "Small_Diff = .5e-6\n" )
    fw.write( "cleandata = 1 * remove sites with ambiguity data (1:yes, 0:no)?\n" )
    fw.write( "* fix_blength = 0 * 0: ignore, -1: random, 1: initial, 2: fixed\n" )
    fw.write( "method = 1 * 0: simultaneous; 1: one branch at a time\n" )
    fw.flush()
    fw.close()
  
  # ---------------------------------------------------------------------------
  def run_codeml( ctlfile ):
    ok = os.system( "~/bin/paml4/bin/codeml " + ctlfile + " > codeml.log" )
    if not (ok % 256 == 0):
      stderr( "codeml exited with an error. aborting, please check log file." )
      sys.exit(3)
  
  # ---------------------------------------------------------------------------
  def parse_file( outfile ):
    hash = {'ns':None, 'ls':None, 'global_KaKs':None}
    fo = open( outfile )
    for line in fo:
      # get number of sequences and number of shared codons within the set
      if line.startswith('ns ='):
        hash['ns'] =  int( re.match( 'ns =\s*(\S+)', line ).group(1) )
        hash['ls'] =  int( re.search( 'ls =\s*(\S+)', line ).group(1) )
      # get global omega (dN/dS)
      if line.startswith('omega (dN/dS) ='):
        hash['global_KaKs'] = float( re.match( 'omega \(dN/dS\) =\s*(\S+)', line ).group(1) )
    fo.close()
    return hash
  
  # ---------------------------------------------------------------------------
  def prepare_annotation( annofile ):
    annohash = {}
    fo = open( annofile, 'r' )
    for line in fo:
      id, shortdescr = line.split("\t")[0:2]
      annohash[id.lower()] = shortdescr
    fo.close()
    return annohash
  
  # ---------------------------------------------------------------------------
  def get_annotation( seqfile, annohash, hash ):
    # get ids
    ids = []
    from Bio import SeqIO
    handle = open(seqfile)
    for seq_record in SeqIO.parse(handle, "fasta"):
      ids.append(seq_record.id.lower())
    handle.close()
    # get annotation and add to hash
    hash['descr'] = None
    for id in ids:
      if annohash.has_key( id ):
        hash['descr'] = annohash.get(id)
        break
    return hash
  
  # ---------------------------------------------------------------------------
  # ---------------------------------------------------------------------------
  # ---------------------------------------------------------------------------
  
  #infomsg( "PAML4 | analyzing orthologous sets for dN/dS" )
  cwd = os.getcwd()
  os.chdir(outdir)
  count = 0
  totalcount = 0
  fw = open( outfile, 'w' )
  fo = open( filelist, 'r' )
  annohash = prepare_annotation( annofile )
  for line in fo:
    if line.startswith('#'):
      totalcount = int(re.search( '\[(\d+)\]', line ).group(1))
      continue
    file = line.split()
    # CODEML
    outfile = get_basename(file[0],0)+'.KaKs' 
    #generate_codeml_ctl_file( 'codeml.ctl', file[4], file[3], outfile )
    #run_codeml( 'codeml.ctl' )
    # parse out file
    hash = parse_file( outfile )
    hash = get_annotation( get_basename(file[0])+'.fa', annohash, hash )
    fw.write( outfile + ' %s %s %s %s\n' 
              %( hash.get('ns'), hash.get('ls'), 
                 hash.get('global_KaKs'), hash.get('descr') ) )
    sysout("\r       percent sets PAMLed: %f" %( 100.0*count/totalcount ))
    count += 1
  sysout("\r       percent sets PAMLed: %f\n" %( 100.0*count/totalcount ))
  fo.close()
  fw.flush()
  fw.close()
  os.chdir(cwd)

# =============================================================================
def main():
  
  args = handle_arguments()
  
  # feed to PAML program
  Ka_Ks_with_PAML( args.get('filelist'), args.get('annofile'), args.get('outdir'), args.get('outfile') )
  
  
### MAIN ######################################################################

main()
  