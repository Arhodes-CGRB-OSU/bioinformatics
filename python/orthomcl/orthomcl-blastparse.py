#!/usr/bin/python
import os, sys, string
import threading, time
import anydbm
from low import *


THREADS = 8
EVALUE = float(1e-5)


def usage():
  print >> sys.stderr, "usage: " + sys.argv[0] + " all.blastout"
  print >> sys.stderr, "    - all.blastout: blast out file generated by NCBI blast (concat all genomes in all one and blastp against itself, -m 8)"
  sys.exit(1)


def plausi():
  if len(sys.argv) != 2: usage()
  inBlast = sys.argv[1]
  if not os.path.exists(inBlast) or not os.path.isfile(inBlast): 
    print >> sys.stderr, "specified blast input file does not exist or is not a file\n"
    usage()
  return inBlast


# =============================================================================
class BlastHit():
  def __init__(self, line):
    cols = line.split("\t")
    self.queryid = cols.pop(0)
    self.subjectid = cols.pop(0)
    self.percentident = float(cols.pop(0))
    self.alnlength = int(cols.pop(0))
    self.mismatch = cols.pop(0)
    self.gap = cols.pop(0)
    self.querystart = cols.pop(0)
    self.queryend = cols.pop(0)
    self.subjectstart = cols.pop(0)
    self.subjectend = cols.pop(0)
    self.evalue = float(cols.pop(0))
    self.score = cols.pop(0)
    

# =============================================================================
def orthomcl_parse(hit_lines):
  simspan = ''
  simspanid = 1
  evalues = []
  sum_identical = 0
  sum_length = 0
  for line in hit_lines:
    b = BlastHit(line)
    evalues.append(b.evalue)
    simspan += str(simspanid) + ":" + b.querystart + "-" + b.queryend + ":" + b.subjectstart + "-" + b.subjectend + "."
    simspanid += 1
    sum_identical += b.percentident * b.alnlength
    sum_length += b.alnlength

  if len(evalues) == 0 or min(evalues) > EVALUE: return 0
  evalue = str(min(evalues))
  percentIdent = str(int(sum_identical / sum_length))
  return string.join( [b.queryid, "0", b.subjectid, "0", evalue, percentIdent, simspan], ";" )
    

# =============================================================================
class Output():
  def __init__(self):
    self.counter = 1
  def write(self, outstring):
    print "%s;%s" % (self.counter, outstring)
    self.counter += 1

# =============================================================================
class MyThread( threading.Thread ):
  def __init__(self, jobs, Out):
    self.jobs = jobs
    self.out = Out

  def run(self):
    for lines in self.jobs:
      outputstring = orthomcl_parse(lines)
      if outputstring != 0: self.out.write(outputstring)

# =============================================================================
def read_gg(file):
  speciesHash = {}
  fo = open(file)
  for line in fo:
    line = line.rstrip()
    cols = line.split()
    speciesname = cols.pop(0)
    speciesname = speciesname[:speciesname.index(':')]
    for id in cols: speciesHash[id] = speciesname
  return speciesHash


def process_file(inBlast):
  Out = Output()
  q1, h1 = "", ""
  done = 0
  info( "\tcounting blast lines to parse..." )
  sout, serr = catch_bash_cmd_output( "wc -l %s" % inBlast )
  totaljobs = int( sout.split()[0] )
  fo = open(inBlast)
  line = fo.readline()
  while threading.activeCount() > 1 or line:
    # check existing threads: still running?
    # fill up all remaining slots
    while threading.activeCount() <= THREADS and line:
      # start new thread
      jobs = []
      while line and len(jobs) < 1000:
        jobs.append([line])
        q2,h2 = line.split("\t")[0:2]
        line = fo.readline()
        done += 1
        while line and line.split("\t")[0:2] == [q2,h2]:
          jobs[-1].append(line)
          line = fo.readline()
          done += 1

      t = MyThread( jobs, Out )
      t.run()

      info( "\t[ jobs done: %s | remain: %s | threads active: %s ] " % ( (totaljobs - done ), done, threading.activeCount() -1) ) 
    time.sleep(0.2)
  fo.close()


def main():
  inBlast = plausi()
  process_file(inBlast)

main()
